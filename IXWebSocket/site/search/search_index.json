{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows Example code # Required on Windows ix::initNetSystem(); # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); Why another library ? There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server.","title":"Home"},{"location":"#introduction","text":"WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows","title":"Introduction"},{"location":"#example-code","text":"# Required on Windows ix::initNetSystem(); # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\");","title":"Example code"},{"location":"#why-another-library","text":"There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server.","title":"Why another library ?"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. [5.1.2] - 2019-09-02 Ping and Pong messages cannot be fragmented (autobahn test: 5.1 and 5.2 Fragmentation) [5.1.1] - 2019-09-01 Close connections when reserved bits are used (autobahn test: 3 Reserved Bits) [5.1.0] - 2019-08-31 ws autobahn / Add code to test websocket client compliance with the autobahn test-suite add utf-8 validation code, not hooked up properly yet Ping received with a payload too large (> 125 bytes) trigger a connection closure cobra / add tracking about published messages cobra / publish returns a message id, that can be used when cobra / new message type in the message received handler when publish/ok is received (can be used to implement an ack system). [5.0.9] - 2019-08-30 User-Agent header is set when not specified. New option to cap the max wait between reconnection attempts. Still default to 10s. (setMaxWaitBetweenReconnectionRetries). ws connect --max_wait 5000 ws://example.com # will only wait 5 seconds max between reconnection attempts [5.0.7] - 2019-08-23 WebSocket: add new option to pass in extra HTTP headers when connecting. ws connect add new option (-H, works like curl ) to pass in extra HTTP headers when connecting If you run against ws echo_server you will see the headers being received printed in the terminal. ws connect -H \"foo: bar\" -H \"baz: buz\" ws://127.0.0.1:8008 CobraConnection: sets a unique id field for all messages sent to cobra . CobraConnection: sets a counter as a field for each event published. [5.0.6] - 2019-08-22 Windows: silly compile error (poll should be in the global namespace) [5.0.5] - 2019-08-22 Windows: use select instead of WSAPoll, through a poll wrapper [5.0.4] - 2019-08-20 Windows build fixes (there was a problem with the use of ::poll that has a different name on Windows (WSAPoll)) [5.0.3] - 2019-08-14 CobraMetricThreadedPublisher _enable flag is an atomic, and CobraMetricsPublisher is enabled by default [5.0.2] - 2019-08-01 ws cobra_subscribe has a new -q (quiet) option ws cobra_subscribe knows to and display msg stats (count and # of messages received per second) ws cobra_subscribe, cobra_to_statsd and cobra_to_sentry commands have a new option, --filter to restrict the events they want to receive [5.0.1] - 2019-07-25 ws connect command has a new option to send in binary mode (still default to text) ws connect command has readline history thanks to libnoise-cpp. Now ws connect one can use using arrows to lookup previous sent messages and edit them [5.0.0] - 2019-06-23 Changed New HTTP server / still very early. ws gained a new command, httpd can run a simple webserver serving local files. IXDNSLookup. Uses weak pointer + smart_ptr + shared_from_this instead of static sets + mutex to handle object going away before dns lookup has resolved cobra_to_sentry / backtraces are reversed and line number is not extracted correctly mbedtls and zlib are searched with find_package, and we use the vendored version if nothing is found travis CI uses g++ on Linux [4.0.0] - 2019-06-09 Changed WebSocket::send() sends message in TEXT mode by default WebSocketMessage sets a new binary field, which tells whether the received incoming message is binary or text WebSocket::send takes a third arg, binary which default to true (can be text too) WebSocket callback only take one object, a const ix::WebSocketMessagePtr& msg Add explicit WebSocket::sendBinary method New headers + WebSocketMessage class to hold message data, still not used across the board Add test/compatibility folder with small servers and clients written in different languages and different libraries to test compatibility. ws echo_server has a -g option to print a greeting message on connect IXSocketMbedTLS: better error handling in close and connect [3.1.2] - 2019-06-06 Added ws connect has a -x option to disable per message deflate Add WebSocket::disablePerMessageDeflate() option. [3.0.0] - 2019-06-xx Changed TLS, aka SSL works on Windows (websocket and http clients) ws command line tool build on Windows Async API for HttpClient HttpClient API changed to use shared_ptr for response and request","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file.","title":"Changelog"},{"location":"CHANGELOG/#512-2019-09-02","text":"Ping and Pong messages cannot be fragmented (autobahn test: 5.1 and 5.2 Fragmentation)","title":"[5.1.2] - 2019-09-02"},{"location":"CHANGELOG/#511-2019-09-01","text":"Close connections when reserved bits are used (autobahn test: 3 Reserved Bits)","title":"[5.1.1] - 2019-09-01"},{"location":"CHANGELOG/#510-2019-08-31","text":"ws autobahn / Add code to test websocket client compliance with the autobahn test-suite add utf-8 validation code, not hooked up properly yet Ping received with a payload too large (> 125 bytes) trigger a connection closure cobra / add tracking about published messages cobra / publish returns a message id, that can be used when cobra / new message type in the message received handler when publish/ok is received (can be used to implement an ack system).","title":"[5.1.0] - 2019-08-31"},{"location":"CHANGELOG/#509-2019-08-30","text":"User-Agent header is set when not specified. New option to cap the max wait between reconnection attempts. Still default to 10s. (setMaxWaitBetweenReconnectionRetries). ws connect --max_wait 5000 ws://example.com # will only wait 5 seconds max between reconnection attempts","title":"[5.0.9] - 2019-08-30"},{"location":"CHANGELOG/#507-2019-08-23","text":"WebSocket: add new option to pass in extra HTTP headers when connecting. ws connect add new option (-H, works like curl ) to pass in extra HTTP headers when connecting If you run against ws echo_server you will see the headers being received printed in the terminal. ws connect -H \"foo: bar\" -H \"baz: buz\" ws://127.0.0.1:8008 CobraConnection: sets a unique id field for all messages sent to cobra . CobraConnection: sets a counter as a field for each event published.","title":"[5.0.7] - 2019-08-23"},{"location":"CHANGELOG/#506-2019-08-22","text":"Windows: silly compile error (poll should be in the global namespace)","title":"[5.0.6] - 2019-08-22"},{"location":"CHANGELOG/#505-2019-08-22","text":"Windows: use select instead of WSAPoll, through a poll wrapper","title":"[5.0.5] - 2019-08-22"},{"location":"CHANGELOG/#504-2019-08-20","text":"Windows build fixes (there was a problem with the use of ::poll that has a different name on Windows (WSAPoll))","title":"[5.0.4] - 2019-08-20"},{"location":"CHANGELOG/#503-2019-08-14","text":"CobraMetricThreadedPublisher _enable flag is an atomic, and CobraMetricsPublisher is enabled by default","title":"[5.0.3] - 2019-08-14"},{"location":"CHANGELOG/#502-2019-08-01","text":"ws cobra_subscribe has a new -q (quiet) option ws cobra_subscribe knows to and display msg stats (count and # of messages received per second) ws cobra_subscribe, cobra_to_statsd and cobra_to_sentry commands have a new option, --filter to restrict the events they want to receive","title":"[5.0.2] - 2019-08-01"},{"location":"CHANGELOG/#501-2019-07-25","text":"ws connect command has a new option to send in binary mode (still default to text) ws connect command has readline history thanks to libnoise-cpp. Now ws connect one can use using arrows to lookup previous sent messages and edit them","title":"[5.0.1] - 2019-07-25"},{"location":"CHANGELOG/#500-2019-06-23","text":"","title":"[5.0.0] - 2019-06-23"},{"location":"CHANGELOG/#changed","text":"New HTTP server / still very early. ws gained a new command, httpd can run a simple webserver serving local files. IXDNSLookup. Uses weak pointer + smart_ptr + shared_from_this instead of static sets + mutex to handle object going away before dns lookup has resolved cobra_to_sentry / backtraces are reversed and line number is not extracted correctly mbedtls and zlib are searched with find_package, and we use the vendored version if nothing is found travis CI uses g++ on Linux","title":"Changed"},{"location":"CHANGELOG/#400-2019-06-09","text":"","title":"[4.0.0] - 2019-06-09"},{"location":"CHANGELOG/#changed_1","text":"WebSocket::send() sends message in TEXT mode by default WebSocketMessage sets a new binary field, which tells whether the received incoming message is binary or text WebSocket::send takes a third arg, binary which default to true (can be text too) WebSocket callback only take one object, a const ix::WebSocketMessagePtr& msg Add explicit WebSocket::sendBinary method New headers + WebSocketMessage class to hold message data, still not used across the board Add test/compatibility folder with small servers and clients written in different languages and different libraries to test compatibility. ws echo_server has a -g option to print a greeting message on connect IXSocketMbedTLS: better error handling in close and connect","title":"Changed"},{"location":"CHANGELOG/#312-2019-06-06","text":"","title":"[3.1.2] - 2019-06-06"},{"location":"CHANGELOG/#added","text":"ws connect has a -x option to disable per message deflate Add WebSocket::disablePerMessageDeflate() option.","title":"Added"},{"location":"CHANGELOG/#300-2019-06-xx","text":"","title":"[3.0.0] - 2019-06-xx"},{"location":"CHANGELOG/#changed_2","text":"TLS, aka SSL works on Windows (websocket and http clients) ws command line tool build on Windows Async API for HttpClient HttpClient API changed to use shared_ptr for response and request","title":"Changed"},{"location":"build/","text":"Build CMake CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool vcpkg It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket Conan Support for building with conan was contributed by Olivia Zoe (thanks !). The package name to reference is IXWebSocket/5.0.0@LunarWatcher/stable . The package is in the process to be published to the official conan package repo, but in the meantime, it can be accessed by adding a new remote conan remote add remote_name_here https://api.bintray.com/conan/oliviazoe0/conan-packages Docker There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Build"},{"location":"build/#build","text":"","title":"Build"},{"location":"build/#cmake","text":"CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool","title":"CMake"},{"location":"build/#vcpkg","text":"It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket","title":"vcpkg"},{"location":"build/#conan","text":"Support for building with conan was contributed by Olivia Zoe (thanks !). The package name to reference is IXWebSocket/5.0.0@LunarWatcher/stable . The package is in the process to be published to the official conan package repo, but in the meantime, it can be accessed by adding a new remote conan remote add remote_name_here https://api.bintray.com/conan/oliviazoe0/conan-packages","title":"Conan"},{"location":"build/#docker","text":"There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Docker"},{"location":"design/","text":"Implementation details Per Message Deflate compression. The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported. TLS/SSL Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL is used on Android and Linux, mbedTLS is used on Windows. Polling and background thread work No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex. Automatic reconnection If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled. Large messages Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully. Testing The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platoform, with different sanitizers such as thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on travis. Limitations On Windows TLS is not setup yet to validate certificates. There is no convenient way to embed a ca cert. No utf-8 validation is made when sending TEXT message with sendText() Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue. C++ code organization Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"Design"},{"location":"design/#implementation-details","text":"","title":"Implementation details"},{"location":"design/#per-message-deflate-compression","text":"The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported.","title":"Per Message Deflate compression."},{"location":"design/#tlsssl","text":"Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL is used on Android and Linux, mbedTLS is used on Windows.","title":"TLS/SSL"},{"location":"design/#polling-and-background-thread-work","text":"No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex.","title":"Polling and background thread work"},{"location":"design/#automatic-reconnection","text":"If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled.","title":"Automatic reconnection"},{"location":"design/#large-messages","text":"Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully.","title":"Large messages"},{"location":"design/#testing","text":"The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platoform, with different sanitizers such as thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on travis.","title":"Testing"},{"location":"design/#limitations","text":"On Windows TLS is not setup yet to validate certificates. There is no convenient way to embed a ca cert. No utf-8 validation is made when sending TEXT message with sendText() Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue.","title":"Limitations"},{"location":"design/#c-code-organization","text":"Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"C++ code organization"},{"location":"usage/","text":"Examples The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage. Windows note To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; } WebSocket client API #include <ixwebsocket/IXWebSocket.h> ... # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop() Sending messages websocket.send(\"foo\") will send a message. If the connection was closed and sending failed, the return value will be set to false. ReadyState getReadyState() returns the state of the connection. There are 4 possible states. ReadyState::Connecting - The connection is not yet open. ReadyState::Open - The connection is open and ready to communicate. ReadyState::Closing - The connection is in the process of closing. ReadyState::Closed - The connection is closed or could not be opened. Open and Close notifications The onMessage event will be fired when the connection is opened or closed. This is similar to the Javascript browser API , which has open and close events notification that can be registered with the browser addEventListener . webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cout << \"send greetings\" << std::endl; // Headers can be inspected (pairs of string/string) std::cout << \"Handshake Headers:\" << std::endl; for (auto it : msg->headers) { std::cout << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Close) { std::cout << \"disconnected\" << std::endl; // The server can send an explicit code and reason for closing. // This data can be accessed through the closeInfo object. std::cout << msg->closeInfo.code << std::endl; std::cout << msg->closeInfo.reason << std::endl; } } ); Error notification A message will be fired when there is an error with the connection. The message type will be ix::WebSocketMessageType::Error . Multiple fields will be available on the event to describe the error. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Error) { std::stringstream ss; ss << \"Error: \" << msg->errorInfo.reason << std::endl; ss << \"#retries: \" << msg->eventInfo.retries << std::endl; ss << \"Wait time(ms): \" << msg->eventInfo.wait_time << std::endl; ss << \"HTTP Status: \" << msg->eventInfo.http_status << std::endl; std::cout << ss.str() << std::endl; } } ); start, stop websocket.start() connect to the remote server and starts the message receiving background thread. websocket.stop() disconnect from the remote server and closes the background thread. Configuring the remote url The url can be set and queried after a websocket object has been created. You will have to call stop and start if you want to disconnect and connect to that new url. std::string url(\"wss://example.com\"); websocket.configure(url); Ping/Pong support Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Ping || msg->type == ix::WebSocketMessageType::Pong) { std::cout << \"pong data: \" << msg->str << std::endl; } } ); A ping message can be sent to the server, with an optional data string. websocket.ping(\"ping data, optional (empty string is ok): limited to 125 bytes long\"); Heartbeat. You can configure an optional heart beat / keep-alive, sent every 45 seconds when there is no any traffic to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45); Supply extra HTTP headers. You can set extra HTTP headers to be sent during the WebSocket handshake. WebSocketHttpHeaders headers; headers[\"foo\"] = \"bar\"; webSocket.setExtraHeaders(headers); Automatic reconnection Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off. webSocket.enableAutomaticReconnection(); // turn on webSocket.disableAutomaticReconnection(); // turn off bool enabled = webSocket.isAutomaticReconnectionEnabled(); // query state The technique to calculate wait time is called exponential backoff . Here are the default waiting times between attempts (from connecting with ws connect ws://foo.com ) > Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently #retries: 1 Wait time(ms): 100 #retries: 2 Wait time(ms): 200 #retries: 3 Wait time(ms): 400 #retries: 4 Wait time(ms): 800 #retries: 5 Wait time(ms): 1600 #retries: 6 Wait time(ms): 3200 #retries: 7 Wait time(ms): 6400 #retries: 8 Wait time(ms): 10000 The waiting time is capped by default at 10s between 2 attempts, but that value can be changed and queried. webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); // 5000ms = 5s uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries(); WebSocket server API #include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait(); HTTP client API #include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async HTTP server API #include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); }","title":"Examples"},{"location":"usage/#examples","text":"The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage.","title":"Examples"},{"location":"usage/#windows-note","text":"To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; }","title":"Windows note"},{"location":"usage/#websocket-client-api","text":"#include <ixwebsocket/IXWebSocket.h> ... # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop()","title":"WebSocket client API"},{"location":"usage/#sending-messages","text":"websocket.send(\"foo\") will send a message. If the connection was closed and sending failed, the return value will be set to false.","title":"Sending messages"},{"location":"usage/#readystate","text":"getReadyState() returns the state of the connection. There are 4 possible states. ReadyState::Connecting - The connection is not yet open. ReadyState::Open - The connection is open and ready to communicate. ReadyState::Closing - The connection is in the process of closing. ReadyState::Closed - The connection is closed or could not be opened.","title":"ReadyState"},{"location":"usage/#open-and-close-notifications","text":"The onMessage event will be fired when the connection is opened or closed. This is similar to the Javascript browser API , which has open and close events notification that can be registered with the browser addEventListener . webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cout << \"send greetings\" << std::endl; // Headers can be inspected (pairs of string/string) std::cout << \"Handshake Headers:\" << std::endl; for (auto it : msg->headers) { std::cout << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Close) { std::cout << \"disconnected\" << std::endl; // The server can send an explicit code and reason for closing. // This data can be accessed through the closeInfo object. std::cout << msg->closeInfo.code << std::endl; std::cout << msg->closeInfo.reason << std::endl; } } );","title":"Open and Close notifications"},{"location":"usage/#error-notification","text":"A message will be fired when there is an error with the connection. The message type will be ix::WebSocketMessageType::Error . Multiple fields will be available on the event to describe the error. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Error) { std::stringstream ss; ss << \"Error: \" << msg->errorInfo.reason << std::endl; ss << \"#retries: \" << msg->eventInfo.retries << std::endl; ss << \"Wait time(ms): \" << msg->eventInfo.wait_time << std::endl; ss << \"HTTP Status: \" << msg->eventInfo.http_status << std::endl; std::cout << ss.str() << std::endl; } } );","title":"Error notification"},{"location":"usage/#start-stop","text":"websocket.start() connect to the remote server and starts the message receiving background thread. websocket.stop() disconnect from the remote server and closes the background thread.","title":"start, stop"},{"location":"usage/#configuring-the-remote-url","text":"The url can be set and queried after a websocket object has been created. You will have to call stop and start if you want to disconnect and connect to that new url. std::string url(\"wss://example.com\"); websocket.configure(url);","title":"Configuring the remote url"},{"location":"usage/#pingpong-support","text":"Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec. webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Ping || msg->type == ix::WebSocketMessageType::Pong) { std::cout << \"pong data: \" << msg->str << std::endl; } } ); A ping message can be sent to the server, with an optional data string. websocket.ping(\"ping data, optional (empty string is ok): limited to 125 bytes long\");","title":"Ping/Pong support"},{"location":"usage/#heartbeat","text":"You can configure an optional heart beat / keep-alive, sent every 45 seconds when there is no any traffic to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45);","title":"Heartbeat."},{"location":"usage/#supply-extra-http-headers","text":"You can set extra HTTP headers to be sent during the WebSocket handshake. WebSocketHttpHeaders headers; headers[\"foo\"] = \"bar\"; webSocket.setExtraHeaders(headers);","title":"Supply extra HTTP headers."},{"location":"usage/#automatic-reconnection","text":"Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off. webSocket.enableAutomaticReconnection(); // turn on webSocket.disableAutomaticReconnection(); // turn off bool enabled = webSocket.isAutomaticReconnectionEnabled(); // query state The technique to calculate wait time is called exponential backoff . Here are the default waiting times between attempts (from connecting with ws connect ws://foo.com ) > Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently #retries: 1 Wait time(ms): 100 #retries: 2 Wait time(ms): 200 #retries: 3 Wait time(ms): 400 #retries: 4 Wait time(ms): 800 #retries: 5 Wait time(ms): 1600 #retries: 6 Wait time(ms): 3200 #retries: 7 Wait time(ms): 6400 #retries: 8 Wait time(ms): 10000 The waiting time is capped by default at 10s between 2 attempts, but that value can be changed and queried. webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); // 5000ms = 5s uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries();","title":"Automatic reconnection"},{"location":"usage/#websocket-server-api","text":"#include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait();","title":"WebSocket server API"},{"location":"usage/#http-client-api","text":"#include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async","title":"HTTP client API"},{"location":"usage/#http-server-api","text":"#include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); }","title":"HTTP server API"},{"location":"ws/","text":"General ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server File transfer # Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path HTTP Client $ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout Cobra Client cobra is a real time messenging server. ws has sub-command to interacti with cobra.","title":"Ws"},{"location":"ws/#general","text":"ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server","title":"General"},{"location":"ws/#file-transfer","text":"# Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path","title":"File transfer"},{"location":"ws/#http-client","text":"$ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout","title":"HTTP Client"},{"location":"ws/#cobra-client","text":"cobra is a real time messenging server. ws has sub-command to interacti with cobra.","title":"Cobra Client"}]}