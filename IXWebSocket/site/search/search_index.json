{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows Example code # Required on Windows ix::initNetSystem(); # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); Why another library ? There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server.","title":"Home"},{"location":"#introduction","text":"WebSocket is a computer communications protocol, providing full-duplex and bi-directionnal communication channels over a single TCP connection. IXWebSocket is a C++ library for client and server Websocket communication, and for client and server HTTP communication. TLS aka SSL is supported. The code is derived from easywsclient and from the Satori C SDK . It has been tested on the following platforms. macOS iOS Linux Android Windows","title":"Introduction"},{"location":"#example-code","text":"# Required on Windows ix::initNetSystem(); # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\");","title":"Example code"},{"location":"#why-another-library","text":"There are 2 main reasons that explain why IXWebSocket got written. First, we needed a C++ cross-platform client library, which should have few dependencies. What looked like the most solid one, websocketpp did depend on boost and this was not an option for us. Secondly, there were other available libraries with fewer dependencies (C ones), but they required calling an explicit poll routine periodically to know if a client had received data from a server, which was not elegant. We started by solving those 2 problems, then we added server websocket code, then an HTTP client, and finally a very simple HTTP server.","title":"Why another library ?"},{"location":"build/","text":"Build CMake CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool vcpkg It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket Conan Support for building with conan was contributed by Olivia Zoe (thanks !). The package name to reference is IXWebSocket/5.0.0@LunarWatcher/stable . The package is in the process to be published to the official conan package repo, but in the meantime, it can be accessed by adding a new remote conan remote add remote_name_here https://api.bintray.com/conan/oliviazoe0/conan-packages Docker There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Build"},{"location":"build/#build","text":"","title":"Build"},{"location":"build/#cmake","text":"CMakefiles for the library and the examples are available. This library has few dependencies, so it is possible to just add the source files into your project. Otherwise the usual way will suffice. mkdir build # make a build dir so that you can build out of tree. cd build cmake -DUSE_TLS=1 .. make -j make install # will install to /usr/local on Unix, on macOS it is a good idea to sudo chown -R `whoami`:staff /usr/local Headers and a static library will be installed to the target dir. There is a unittest which can be executed by typing make test . Options for building: -DUSE_TLS=1 will enable TLS support -DUSE_MBED_TLS=1 will use mbedlts for the TLS support (default on Windows) -DUSE_WS=1 will build the ws interactive command line tool","title":"CMake"},{"location":"build/#vcpkg","text":"It is possible to get IXWebSocket through Microsoft vcpkg . vcpkg install ixwebsocket","title":"vcpkg"},{"location":"build/#conan","text":"Support for building with conan was contributed by Olivia Zoe (thanks !). The package name to reference is IXWebSocket/5.0.0@LunarWatcher/stable . The package is in the process to be published to the official conan package repo, but in the meantime, it can be accessed by adding a new remote conan remote add remote_name_here https://api.bintray.com/conan/oliviazoe0/conan-packages","title":"Conan"},{"location":"build/#docker","text":"There is a Dockerfile for running the unittest on Linux, and to run the ws tool. It is also available on the docker registry. docker run bsergean/ws To use docker-compose you must make a docker container first. $ make docker ... $ docker compose up & ... $ docker exec -it ixwebsocket_ws_1 bash app@ca2340eb9106:~$ ws --help ws is a websocket tool ...","title":"Docker"},{"location":"design/","text":"Implementation details Per Message Deflate compression. The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported. TLS/SSL Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL is used on Android and Linux, mbedTLS is used on Windows. Polling and background thread work No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex. Automatic reconnection If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled. Large messages Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully. Testing The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platoform, with different sanitizers such as thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on travis. Limitations On Windows TLS is not setup yet to validate certificates. There is no convenient way to embed a ca cert. No utf-8 validation is made when sending TEXT message with sendText() Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue. C++ code organization Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"Design"},{"location":"design/#implementation-details","text":"","title":"Implementation details"},{"location":"design/#per-message-deflate-compression","text":"The per message deflate compression option is supported. It can lead to very nice bandbwith savings (20x !) if your messages are similar, which is often the case for example for chat applications. All features of the spec should be supported.","title":"Per Message Deflate compression."},{"location":"design/#tlsssl","text":"Connections can be optionally secured and encrypted with TLS/SSL when using a wss:// endpoint, or using normal un-encrypted socket with ws:// endpoints. AppleSSL is used on iOS and macOS, OpenSSL is used on Android and Linux, mbedTLS is used on Windows.","title":"TLS/SSL"},{"location":"design/#polling-and-background-thread-work","text":"No manual polling to fetch data is required. Data is sent and received instantly by using a background thread for receiving data and the select system call to be notified by the OS of incoming data. No timeout is used for select so that the background thread is only woken up when data is available, to optimize battery life. This is also the recommended way of using select according to the select tutorial, section select law . Read and Writes to the socket are non blocking. Data is sent right away and not enqueued by writing directly to the socket, which is possible since system socket implementations allow concurrent read/writes. However concurrent writes need to be protected with mutex.","title":"Polling and background thread work"},{"location":"design/#automatic-reconnection","text":"If the remote end (server) breaks the connection, the code will try to perpetually reconnect, by using an exponential backoff strategy, capped at one retry every 10 seconds. This behavior can be disabled.","title":"Automatic reconnection"},{"location":"design/#large-messages","text":"Large frames are broken up into smaller chunks or messages to avoid filling up the os tcp buffers, which is permitted thanks to WebSocket fragmentation . Messages up to 1G were sent and received succesfully.","title":"Large messages"},{"location":"design/#testing","text":"The library has an interactive tool which is handy for testing compatibility ith other libraries. We have tested our client against Python, Erlang, Node.js, and C++ websocket server libraries. The unittest tries to be comprehensive, and has been running on multiple platoform, with different sanitizers such as thread sanitizer to catch data races or the undefined behavior sanitizer. The regression test is running after each commit on travis.","title":"Testing"},{"location":"design/#limitations","text":"On Windows TLS is not setup yet to validate certificates. There is no convenient way to embed a ca cert. No utf-8 validation is made when sending TEXT message with sendText() Automatic reconnection works at the TCP socket level, and will detect remote end disconnects. However, if the device/computer network become unreachable (by turning off wifi), it is quite hard to reliably and timely detect it at the socket level using recv and send error codes. Here is a good discussion on the subject. This behavior is consistent with other runtimes such as node.js. One way to detect a disconnected device with low level C code is to do a name resolution with DNS but this can be expensive. Mobile devices have good and reliable API to do that. The server code is using select to detect incoming data, and creates one OS thread per connection. This is not as scalable as strategies using epoll or kqueue.","title":"Limitations"},{"location":"design/#c-code-organization","text":"Here is a simplistic diagram which explains how the code is structured in term of class/modules. +-----------------------+ --- Public | | Start the receiving Background thread. Auto reconnection. Simple websocket Ping. | IXWebSocket | Interface used by C++ test clients. No IX dependencies. | | +-----------------------+ | | | IXWebSocketServer | Run a server and give each connections its own WebSocket object. | | Each connection is handled in a new OS thread. | | +-----------------------+ --- Private | | | IXWebSocketTransport | Low level websocket code, framing, managing raw socket. Adapted from easywsclient. | | +-----------------------+ | | | IXWebSocketHandshake | Establish the connection between client and server. | | +-----------------------+ | | | IXWebSocket | ws:// Unencrypted Socket handler | IXWebSocketAppleSSL | wss:// TLS encrypted Socket AppleSSL handler. Used on iOS and macOS | IXWebSocketOpenSSL | wss:// TLS encrypted Socket OpenSSL handler. Used on Android and Linux | | Can be used on macOS too. +-----------------------+ | | | IXSocketConnect | Connect to the remote host (client). | | +-----------------------+ | | | IXDNSLookup | Does DNS resolution asynchronously so that it can be interrupted. | | +-----------------------+","title":"C++ code organization"},{"location":"usage/","text":"Examples The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage. Windows note To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; } WebSocket client API #include <ixwebsocket/IXWebSocket.h> ... # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop() WebSocket server API #include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait(); HTTP client API #include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async HTTP server API #include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); }","title":"Usage"},{"location":"usage/#examples","text":"The ws folder countains many interactive programs for chat, file transfers , curl like http clients, demonstrating client and server usage.","title":"Examples"},{"location":"usage/#windows-note","text":"To use the network system on Windows, you need to initialize it once with WSAStartup() and clean it up with WSACleanup() . We have helpers for that which you can use, see below. This init would typically take place in your main function. #include <ixwebsocket/IXNetSystem.h> int main() { ix::initNetSystem(); ... ix::uninitNetSystem(); return 0; }","title":"Windows note"},{"location":"usage/#websocket-client-api","text":"#include <ixwebsocket/IXWebSocket.h> ... # Our websocket object ix::WebSocket webSocket; std::string url(\"ws://localhost:8080/\"); webSocket.setUrl(url); // Optional heart beat, sent every 45 seconds when there is not any traffic // to make sure that load balancers do not kill an idle connection. webSocket.setHeartBeatPeriod(45); // Per message deflate connection is enabled by default. You can tweak its parameters or disable it webSocket.disablePerMessageDeflate(); // Setup a callback to be fired when a message or an event (open, close, error) is received webSocket.setOnMessageCallback([](const ix::WebSocketMessagePtr& msg) { if (msg->type == ix::WebSocketMessageType::Message) { std::cout << msg->str << std::endl; } } ); // Now that our callback is setup, we can start our background thread and receive messages webSocket.start(); // Send a message to the server (default to TEXT mode) webSocket.send(\"hello world\"); // The message can be sent in BINARY mode (useful if you send MsgPack data for example) webSocket.sendBinary(\"some serialized binary data\"); // ... finally ... // Stop the connection webSocket.stop()","title":"WebSocket client API"},{"location":"usage/#websocket-server-api","text":"#include <ixwebsocket/IXWebSocketServer.h> ... // Run a server on localhost at a given port. // Bound host name, max connections and listen backlog can also be passed in as parameters. ix::WebSocketServer server(port); server.setOnConnectionCallback( [&server](std::shared_ptr<WebSocket> webSocket, std::shared_ptr<ConnectionState> connectionState) { webSocket->setOnMessageCallback( [webSocket, connectionState, &server](const ix::WebSocketMessagePtr msg) { if (msg->type == ix::WebSocketMessageType::Open) { std::cerr << \"New connection\" << std::endl; // A connection state object is available, and has a default id // You can subclass ConnectionState and pass an alternate factory // to override it. It is useful if you want to store custom // attributes per connection (authenticated bool flag, attributes, etc...) std::cerr << \"id: \" << connectionState->getId() << std::endl; // The uri the client did connect to. std::cerr << \"Uri: \" << msg->openInfo.uri << std::endl; std::cerr << \"Headers:\" << std::endl; for (auto it : msg->openInfo.headers) { std::cerr << it.first << \": \" << it.second << std::endl; } } else if (msg->type == ix::WebSocketMessageType::Message) { // For an echo server, we just send back to the client whatever was received by the server // All connected clients are available in an std::set. See the broadcast cpp example. // Second parameter tells whether we are sending the message in binary or text mode. // Here we send it in the same mode as it was received. webSocket->send(msg->str, msg->binary); } } ); } ); auto res = server.listen(); if (!res.first) { // Error handling return 1; } // Run the server in the background. Server can be stoped by calling server.stop() server.start(); // Block until server.stop() is called. server.wait();","title":"WebSocket server API"},{"location":"usage/#http-client-api","text":"#include <ixwebsocket/IXHttpClient.h> ... // // Preparation // HttpClient httpClient; HttpRequestArgsPtr args = httpClient.createRequest(); // Custom headers can be set WebSocketHttpHeaders headers; headers[\"Foo\"] = \"bar\"; args->extraHeaders = headers; // Timeout options args->connectTimeout = connectTimeout; args->transferTimeout = transferTimeout; // Redirect options args->followRedirects = followRedirects; args->maxRedirects = maxRedirects; // Misc args->compress = compress; // Enable gzip compression args->verbose = verbose; args->logger = [](const std::string& msg) { std::cout << msg; }; // // Synchronous Request // HttpResponsePtr out; std::string url = \"https://www.google.com\"; // HEAD request out = httpClient.head(url, args); // GET request out = httpClient.get(url, args); // POST request with parameters HttpParameters httpParameters; httpParameters[\"foo\"] = \"bar\"; out = httpClient.post(url, httpParameters, args); // POST request with a body out = httpClient.post(url, std::string(\"foo=bar\"), args); // // Result // auto statusCode = response->statusCode; // Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc... auto errorCode = response->errorCode; // 200, 404, etc... auto responseHeaders = response->headers; // All the headers in a special case-insensitive unordered_map of (string, string) auto payload = response->payload; // All the bytes from the response as an std::string auto errorMsg = response->errorMsg; // Descriptive error message in case of failure auto uploadSize = response->uploadSize; // Byte count of uploaded data auto downloadSize = response->downloadSize; // Byte count of downloaded data // // Asynchronous Request // bool async = true; HttpClient httpClient(async); auto args = httpClient.createRequest(url, HttpClient::kGet); // Push the request to a queue, bool ok = httpClient.performRequest(args, [](const HttpResponsePtr& response) { // This callback execute in a background thread. Make sure you uses appropriate protection such as mutex auto statusCode = response->statusCode; // acess results } ); // ok will be false if your httpClient is not async","title":"HTTP client API"},{"location":"usage/#http-server-api","text":"#include <ixwebsocket/IXHttpServer.h> ix::HttpServer server(port, hostname); auto res = server.listen(); if (!res.first) { std::cerr << res.second << std::endl; return 1; } server.start(); server.wait(); If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example. setOnConnectionCallback( [this](HttpRequestPtr request, std::shared_ptr<ConnectionState> /*connectionState*/) -> HttpResponsePtr { // Build a string for the response std::stringstream ss; ss << request->method << \" \" << request->uri; std::string content = ss.str(); return std::make_shared<HttpResponse>(200, \"OK\", HttpErrorCode::Ok, WebSocketHttpHeaders(), content); }","title":"HTTP server API"},{"location":"ws/","text":"General ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server File transfer # Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path HTTP Client $ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout Cobra Client cobra is a real time messenging server. ws has sub-command to interacti with cobra.","title":"Ws"},{"location":"ws/#general","text":"ws is a command line tool that should exercise most of the IXWebSocket code, and provide example code. ws is a websocket tool Usage: ws [OPTIONS] SUBCOMMAND Options: -h,--help Print this help message and exit Subcommands: send Send a file receive Receive a file transfer Broadcasting server connect Connect to a remote server chat Group chat echo_server Echo server broadcast_server Broadcasting server ping Ping pong curl HTTP Client redis_publish Redis publisher redis_subscribe Redis subscriber cobra_subscribe Cobra subscriber cobra_publish Cobra publisher cobra_to_statsd Cobra to statsd cobra_to_sentry Cobra to sentry snake Snake server httpd HTTP server","title":"General"},{"location":"ws/#file-transfer","text":"# Start transfer server, which is just a broadcast server at this point ws transfer # running on port 8080. # Start receiver first ws receive ws://localhost:8080 # Then send a file. File will be received and written to disk by the receiver process ws send ws://localhost:8080 /file/to/path","title":"File transfer"},{"location":"ws/#http-client","text":"$ ws curl --help HTTP Client Usage: ws curl [OPTIONS] url Positionals: url TEXT REQUIRED Connection url Options: -h,--help Print this help message and exit -d TEXT Form data -F TEXT Form data -H TEXT Header --output TEXT Output file -I Send a HEAD request -L Follow redirects --max-redirects INT Max Redirects -v Verbose -O Save output to disk --compress Enable gzip compression --connect-timeout INT Connection timeout --transfer-timeout INT Transfer timeout","title":"HTTP Client"},{"location":"ws/#cobra-client","text":"cobra is a real time messenging server. ws has sub-command to interacti with cobra.","title":"Cobra Client"}]}